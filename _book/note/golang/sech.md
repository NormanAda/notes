[TOC]

# 协程调度

## 调度器的三个基本对象

- G (Goroutine)，代表协程
- M (Work Thread)，工作线程
- P (Processor)，代表一个`处理器`，又称上下文

G-M-P三者的关系与特点：

- 每一个运行的 M 都必须绑定一个 P，线程M 创建后会去检查并执行G (goroutine)对象
- 每一个 P 保存着一个协程G 的`队列`
- 除了每个 P 自身保存的 G 的队列外，调度器还拥有一个全局的 G 队列
- M 从`队列中`提取 G，并执行
- P 的个数就是`GOMAXPROCS`（最大256），启动时固定的，一般不修改
- M 的个数和 P 的个数不一定一样多（会有休眠的M 或 P不绑定M ）（最大10000）
- P 是用一个全局数组（255）来保存的，并且维护着一个全局的 P 空闲链表

### 局部G队列与全局G队列的关系 

- 全局G任务队列会和各个本地G任务队列按照一定的策略互相交换。没错，就是`协程任务`交换
- G任务的执行顺序是，先从本地队列找，本地没有则从`全局队列`找
- 转移
  - 局部与全局，全局G个数 / P个数
  - 局部与局部，一次性转移一半

## Gorutine从入队到执行

1. 当创建一个G对象，就是 `gorutine`，它会加入到本地队列或者全局队列
2. 如果还有空闲的P，则创建一个M 绑定该 P ,P 此前必须还没绑定过M 的，否则不满足空闲的条件。
   1. 先找到一个空闲的P，如果没有则直接返回
   2. P 个数不会占用超过自己设定的cpu个数
   3. P 在被 M 绑定后，就会初始化自己的 G 队列，此时是一个`空队列`
   4. 无论在哪个 M 中创建了一个 G，只要 P 有空闲的，就会引起新 M 的创建,不需考虑当前所在 M 中所绑的 P 的 G 队列是否已满
   5. 新创建的 M 所绑的 P 的初始化队列会从其他 G 队列中取任务过来
3. M 会启动一个`底层线程`，`循环执行`能找到的 G 任务。
4. G任务的执行顺序是，先从本地队列找，本地没有则从全局队列找
5. 程序启动的时候，首先跑的是主线程，然后这个主线程会绑定第一个 P
6. 入口 main 函数，其实是作为一个 goroutine 来执行

## 调度

协程的切换时间片是10ms，也就是说 goroutine 最多执行10ms就会被 M 切换到下一个 G。这个过程，又被称为 `中断，挂起`

go程序启动时会首先创建一个特殊的内核线程 `sysmon`，用来监控和管理，其内部是一个循环：

1. 记录所有 P 的 G 任务的`计数 schedtick`，schedtick会在每执行一个G任务后递增
2. 如果检查到 `schedtick` 一直没有递增，说明这个 P 一直在执行同一个 G 任务，如果超过10ms，就在这个G任务的栈信息里面加一个 tag 标记
3. 然后这个 G 任务在执行的时候，如果遇到非内联函数调用，就会检查一次这个标记，然后中断自己，把自己加到队列末尾，执行下一个G
4. 如果没有遇到`非内联函数` 调用（有时候正常的小函数会被优化成内联函数）的话，那就会一直执行这个G任务，直到它自己结束；如果是个死循环，并且 GOMAXPROCS=1 的话。那么一直只会只有一个 P 与一个 M，且队列中的其他 G 不会被执行！

下面的这段代码，`hello world` 不会被输出

```go
func main(){
    runtime.GOMAXPROCS(1)
    go func(){
    	fmt.Println("hello world")
    	// panic("hello world")  // 强制观察输出
    }()
    go func(){
    	for {
            // fmt.Println("aaa")  // 非内联函数，这行注释打开，将导致 hello world 的输出
    	}
    }()
    select {}
}
```

### 中断后的恢复

1. 中断的时候将寄存器里的栈信息，保存到自己的 G 对象里面
2. 当再次轮到自己执行时，将自己保存的栈信息复制到寄存器里面，这样就接着上次之后运

## GOMAXPROCS--性能调优

`GOMAXPROCS` 就是 go 中 runtime 包的一个函数。它设置了 P 的最多的个数。这也就直接导致了 M 最多的个数是多少，而 M 的个数就决定了各个 G 队列能同时被多少个 M 线程来进行调取执行！

故一般将 GOMAXPROCS 的个数设置为 CPU 的核数，且需要注意的是：

- go 1.5 版本之前的 GOMAXPROCS 默认是 1
- go 1.5 版本之后的 GOMAXPROCS 默认是 Num of cpu

