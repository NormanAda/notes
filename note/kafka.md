## 基础

消息引擎能够有效地对抗上游的流量冲击，真正做到将上游的“峰”填满到“谷”中，避免了流量的震荡。消息引擎系统的另一大好处在于发送方和接收方的松耦合，这也在一定程度上简化了应用的开发，减少了系统间不必要的交互。

在 Kafka 中，发布订阅的对象是主题（Topic），可以为每个业务，每类数据都创建专属的主题。向主题发布消息的客户端应用程序称为生产者（Producer），生产者程序通常持续不断地向一个或多个主题发送消息，而订阅这.些主题消息的客户端应用程序就被称为消费者（Consumer）。把生产者和消费者统称为客户端（Clients）。Kafka 的服务器端由被称为 Broker 的服务进程构成，Broker 负责接收和处理客户端发送过来的请求，以及对消息进行持久化。

Kafka 定义了两类副本：领导者副本（Leader Replica）和追随者副本（Follower Replica）。生产者总是向领导者副本写消息；而消费者总是从领导者副本读消息。至于追随者副本，它只做一件事：向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者的同步。

倘若领导者副本积累了太多的数据以至于单台 Broker 机器都无法容纳了，此时应该怎么办呢？

- 分区（Partitioning）：把数据分割成多份保存在不同的 Broker 上。

- 将每个主题划分成多个分区（Partition），每个分区是一组有序的消息日志。生产者生产的每条消息只会被发送到一个分区中，Kafka 的分区编号是从 0 开始的，如果 Topic 有100 个分区，那么它们的分区号就是从 0 到 99。

- 副本是在分区这个层级定义的。每个分区下可以配置若干个副本，其中只能有 1 个领导者副本和 N-1 个追随者副本。

  每条消息在分区中的位置信息由一个叫位移（Offset）的数据来表征。分区位移总是从 0 开始。

  1. 第一层是主题层，每个主题可以配置 M 个分区，而每个分区又可N个副本。
  2. 第二层是分区层，每个分区的 N 个副本中只能有一个充当领导者。
  3. 第三层是消息层，分区中包含若干条消息，每条消息的位移从 0开始，依次递增。
  4.  最后，客户端程序只能与分区的领导者副本进行交互。

Kafka 使用消息日志（Log）来保存数据，一个日志就是磁盘上一个只能追加写（Append-only）消息的物理.文件。因为只能追加写入，故避免了缓慢的随机 I/O 操作，改为性能较好的顺序 I/O 写操作，这也是实现 Kafka 高.吞吐量特性的一个重要手段。在 Kafka 底层，一个日志又近一步细分成多个日志段，消息被追加写到当前最新的日志段中，当写满了一个日志段后，Kafka 会自动切分出一个新的日志段，并将老的日志段封存起来。后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。

点对点指的是同一条消息只能被下游的一个消费者消费，在 Kafka 中实现这种 P2P 模型的方法就是引入了消费者组，消费者组，指的是多个消费者实例共同组成一个组来消费一组主题。这组主题中的每个分区都只会被组内的一个消费者实例消费，其他消费者实例不能消费它。主要是为了提升消费者端的吞吐量。

重平衡（Rebalance）：假设组内某个实例挂掉了，Kafka 能够自动检测到，然后把这个 Failed 实例之前负责的分区转移给其他活着的消费者。

每个消费者在消费消息的过程中必然需要有个字段记录它当前消费到了分区的哪个位置上，这个字段就是消费者位移（Consumer Offset）,是消费者消费进度的指示器。

**为什么 Kafka 不像 MySQL 那样允许追随者副本对外提供读服务？**

1. kafka的分区已经让读是从多个broker读从而负载均衡，不是MySQL的主从，压力都在主上。
2. 如果从kafka的follower读，消费端offset控制更复杂。

极客时间版权所有: https://time.geekbang.org/column/article/99318

## 常用版本

Apache Kafka:版本迭代速度最快,劣势在于它仅仅提供最最基础的组件，社区版 Kafka 只提供一种连接器，即读写磁盘文件的连接器,而没有与其他外部系统交互的连接器,没有提供任何监控框架或工具。目前有一些开源的监控框架可以帮助用于监控 Kafka（比如 Kafka manager）。总而言之，如果仅仅需要一个消息引擎系统亦或是简单的流处理应用场景，同时需要对系统有较大把控度，那么推荐使用Apache Kafka.迭代速度快，社区响应度高，使用它可以让你有更高的把控度；缺陷在于仅提供基础核心组件，缺失一些高级的特性。

Confluent Kafka:免费版还包含 Schema 注册中心和 REST proxy,前者是帮助你集中管理 Kafka 消息格式以实现数据前向 /后向兼容，后者用开放 HTTP 接口的方式允许你通过网络访问 Kafka 的各种功能，除此之外，免费版包含了更多的连接器。企业版，最有用的当属跨数据中心备份和集群监控两大功能了。多个数据中心之间数据的同步以及对集群的监控历来是Kafka 的痛点。它集成了很多高级特性且由 Kafka 原班人马打造，质量上有保证，但是公司暂时没有发展国内业务的计划，相关的资料以及技术支持都很欠缺。

CDH/HDP Kafka：便捷化的界面操作将 Kafka 的安装、运维、管理、监控全部统一在控制台中，所有的操作都可以在前端 UI 界面上完成，而不必去执行复杂的kafka命令。这些平台提供的监控界面也非常友好，你通常不需要进行任何配置就能有效地监控 Kafka，操作简单，节省运维成本，但是直接降低了对 Kafka 集群的掌控程度，对下层的 Kafka 集群一无所知，怎么能做到心中有数呢。另一个弊端在于它的滞后性。

## 主要演进版本

版本号：大 + 小 + patch

0.7版本:只有基础消息队列功能，无副本；打死也不使用

0.8版本:增加了副本机制，能够比较好地做到消息无丢失.新的producer API,需要指定 Broker 地址的 Produce而非ZooKeeper 的地址；建议使用0.8.2.2版本，因为该版本中老版本消费者 API 是比较稳定的；不建议使用0.8.2.0之后的producer API。

极客时间版权所有: https://time.geekbang.org/column/article/100726；建议使用0.8.2.2版本；不建议使用0.8.2.0之后的producer API

0.9版本:增加权限和认证，新的consumer API；还引入了 Kafka Connect 组件用于实现高性能的数据抽取。不建议使用consumer API；

0.10版本:引入Kafka Streams功能，bug修复；建议版本0.10.2.2；建议使用新版consumer API

0.11版本:producer API幂等，事物API，消息格式重构；建议版本0.11.0.3；谨慎对待消息格式变化

1.0和2.0版本:Kafka Streams改进；建议版本2.0；

极客时间版权所有: https://time.geekbang.org/column/article/100285